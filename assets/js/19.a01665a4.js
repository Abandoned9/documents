(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{594:function(t,s,a){"use strict";a.r(s);var r=a(6),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("       自从读大学以来，我就再也没有接触过C语言，虽然很怀念以前在职高的时候彻夜刷算法题，那时候我还只是个刚入C\n语言门的小白，一年时间也让我对代码的陌生感慢慢消除，这也为我后来在大学里学习Java打下了基础。虽然Java的世界很精彩，导致我大学三年沉迷其中无法自拔，\n但偶尔还是会想起C语言的好，如今已参加工作，但回想起那段刷题的时间还是令我无比怀念，于是我又打开了letCode，下载jetBrains的Clion，找找以前高中彻夜刷题的感觉！\n😁")])]),t._v(" "),a("h2",{attrs:{id:"安装clion-配置c语言基础开发环境"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装clion-配置c语言基础开发环境"}},[t._v("#")]),t._v(" 安装Clion，配置C语言基础开发环境")]),t._v(" "),a("h3",{attrs:{id:"需要准备的工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#需要准备的工具"}},[t._v("#")]),t._v(" 需要准备的工具")]),t._v(" "),a("ul",[a("li",[t._v("Clion")]),t._v(" "),a("li",[t._v("MinGW")])]),t._v(" "),a("p",[t._v("1.首先我们需要去"),a("a",{attrs:{href:"https://www.jetbrains.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("JetBrains官网"),a("OutboundLink")],1),t._v("\n下载Clion(这里推荐一下jetBrains的 "),a("code",[t._v("Toolbox App")]),t._v(" 一键下载全家桶，更新升级快捷方便！)\n如果需要正版可以去淘宝购买，一年也就10块钱并不贵")]),t._v(" "),a("p",[t._v("2.下载"),a("a",{attrs:{href:"https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/",target:"_blank",rel:"noopener noreferrer"}},[t._v("MinGW"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("根据系统位数\n选择下载一个压缩包，如果下载速度过慢请自行寻找某不科学的上网方式=。=\n"),a("img",{attrs:{src:"https://dyblog-oss.oss-cn-beijing.aliyuncs.com/blogimgs/V5P%24ZRI4%29%24Z0HGAYI%5BUS990.png",alt:""}})]),t._v(" "),a("p",[t._v("下载完之后解压放到任意位置，打开Clion，会提示你配置MinGW的路径，然后选择该路径，例如我的路径是"),a("code",[t._v("C:\\Program Files\\mingw64")]),t._v("\n则在File > Settings > Build, Execution, Deployment > Toolchains设置如图：\n"),a("img",{attrs:{src:"https://dyblog-oss.oss-cn-beijing.aliyuncs.com/blogimgs/5.png",alt:""}})]),t._v(" "),a("h4",{attrs:{id:"然后创建项目目录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#然后创建项目目录"}},[t._v("#")]),t._v(" 然后创建项目目录")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://dyblog-oss.oss-cn-beijing.aliyuncs.com/blogimgs/6.png",alt:""}})]),t._v(" "),a("h4",{attrs:{id:"选择"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#选择"}},[t._v("#")]),t._v(" 选择")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://dyblog-oss.oss-cn-beijing.aliyuncs.com/blogimgs/7.png",alt:""}})]),t._v(" "),a("p",[t._v("自定义项目目录，下面的Language standard选择你需要的标准")]),t._v(" "),a("p",[t._v("我们这里一般使用C99标准")]),t._v(" "),a("p",[t._v("这里解释一下C99主要的特点"),a("code",[t._v("取自百度百科")])]),t._v(" "),a("h2",{attrs:{id:"c99"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#c99"}},[t._v("#")]),t._v(" C99")]),t._v(" "),a("blockquote",[a("p",[t._v("C99 （以前称为C9X ）是ISO / IEC 9899：1999的非正式名称，在1999年推出，被ANSI于2000年3月采用。它是C编程语言标准的过去版本。 它扩展了以前的版本（ C90 ），增加了语言和标准库的新功能，并帮助实现更好地利用可用的计算机硬件，如IEEE 754-1985浮点运算和编译器技术，最主要的增强在数值处理上。 2011年发布的C编程语言标准的C11版本取代了C99。")]),t._v(" "),a("h3",{attrs:{id:"增加restrict指针"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#增加restrict指针"}},[t._v("#")]),t._v(" 增加restrict指针")]),t._v(" "),a("blockquote",[a("p",[t._v("C99中增加了适用于指针的 restrict 类型修饰符，它是初始访问指针所指对象的惟一途径，因此只有借助restrict 指针表达式才能访问对象。restrict 指针主要用做函数形参，或者指向由malloc( ) 函数所分配的内存变量。restrict 数据类型不改变程序的语义。")])]),t._v(" "),a("h3",{attrs:{id:"inline-内联-关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inline-内联-关键字"}},[t._v("#")]),t._v(" inline(内联)关键字")]),t._v(" "),a("blockquote",[a("p",[t._v("内联函数除了保持结构化和函数式的定义方式外，还能使程序员写出高效率的代码。如函数在代码内进行内联扩展，则执行代码时，函数与参数不需进栈与退栈，各种寄存器内容不需保存与恢复。")])]),t._v(" "),a("h3",{attrs:{id:"新增数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新增数据类型"}},[t._v("#")]),t._v(" 新增数据类型")]),t._v(" "),a("blockquote",[a("p",[t._v("_Bool：值是0或1，C99中增加了用来定义bool，true以及false 宏的头文件< stdbool. h>，以便程序员能够编写同时兼容于C与C++的应用程序，在编写新的应用程序时，应该使用< stdbool. h >头文件的 bool 宏。")])]),t._v(" "),a("h3",{attrs:{id:"对数组的增强"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对数组的增强"}},[t._v("#")]),t._v(" 对数组的增强")]),t._v(" "),a("blockquote",[a("p",[t._v("可变长数组(VLA)：C99中，程序员声明数组时，数组的维数可以由任意有效的整型表达式确定，包括只在运行时才能确定其值的表达式，这类数组就叫做可变长数组。但是只有局部数组才可以是变长的。可变长数组的维数在数组生存期内是不变的，也就是说，可变长数组不是动态的。可以变化的只是数组的大小。可以使用*来定义不确定长的可变长数组。")])]),t._v(" "),a("h3",{attrs:{id:"for语句内的变量声明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for语句内的变量声明"}},[t._v("#")]),t._v(" for语句内的变量声明")]),t._v(" "),a("blockquote",[a("p",[t._v("C99中，程序员可以在for语句的初始化部分定义一个或多个变量，这些变量的作用域仅于本for语句所控制的循环体内。C编译器接受作为for循环语句中第一个表达式的类型声明：")]),t._v(" "),a("div",{staticClass:"language-C line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("； i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("； i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//1oop body ")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("；\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("for循环的初始化语句中声明的任何变量的作用域是整个循环(包括控制和迭代表达式)。")])]),t._v(" "),a("h3",{attrs:{id:"复合赋值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复合赋值"}},[t._v("#")]),t._v(" 复合赋值")]),t._v(" "),a("h3",{attrs:{id:"printf-和-scanf-函数系列的增强"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#printf-和-scanf-函数系列的增强"}},[t._v("#")]),t._v(" printf()和 scanf()函数系列的增强")])]),t._v(" "),a("p",[t._v("然后开启你的C语言算法之旅吧~ =。=\n"),a("img",{attrs:{src:"https://dyblog-oss.oss-cn-beijing.aliyuncs.com/blogimgs/8.png",alt:""}})])])}),[],!1,null,null,null);s.default=e.exports}}]);